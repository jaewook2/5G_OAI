/**
 * Namf_Communication
 * AMF Communication Service Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
 *
 * The version of the OpenAPI document: 1.1.5
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINrLocation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINrLocation::OAINrLocation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINrLocation::OAINrLocation() {
    this->initializeModel();
}

OAINrLocation::~OAINrLocation() {}

void OAINrLocation::initializeModel() {

    m_tai_isSet = false;
    m_tai_isValid = false;

    m_ncgi_isSet = false;
    m_ncgi_isValid = false;

    m_age_of_location_information_isSet = false;
    m_age_of_location_information_isValid = false;

    m_ue_location_timestamp_isSet = false;
    m_ue_location_timestamp_isValid = false;

    m_geographical_information_isSet = false;
    m_geographical_information_isValid = false;

    m_geodetic_information_isSet = false;
    m_geodetic_information_isValid = false;

    m_global_gnb_id_isSet = false;
    m_global_gnb_id_isValid = false;
}

void OAINrLocation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINrLocation::fromJsonObject(QJsonObject json) {

    m_tai_isValid = ::OpenAPI::fromJsonValue(tai, json[QString("tai")]);
    m_tai_isSet = !json[QString("tai")].isNull() && m_tai_isValid;

    m_ncgi_isValid = ::OpenAPI::fromJsonValue(ncgi, json[QString("ncgi")]);
    m_ncgi_isSet = !json[QString("ncgi")].isNull() && m_ncgi_isValid;

    m_age_of_location_information_isValid = ::OpenAPI::fromJsonValue(age_of_location_information, json[QString("ageOfLocationInformation")]);
    m_age_of_location_information_isSet = !json[QString("ageOfLocationInformation")].isNull() && m_age_of_location_information_isValid;

    m_ue_location_timestamp_isValid = ::OpenAPI::fromJsonValue(ue_location_timestamp, json[QString("ueLocationTimestamp")]);
    m_ue_location_timestamp_isSet = !json[QString("ueLocationTimestamp")].isNull() && m_ue_location_timestamp_isValid;

    m_geographical_information_isValid = ::OpenAPI::fromJsonValue(geographical_information, json[QString("geographicalInformation")]);
    m_geographical_information_isSet = !json[QString("geographicalInformation")].isNull() && m_geographical_information_isValid;

    m_geodetic_information_isValid = ::OpenAPI::fromJsonValue(geodetic_information, json[QString("geodeticInformation")]);
    m_geodetic_information_isSet = !json[QString("geodeticInformation")].isNull() && m_geodetic_information_isValid;

    m_global_gnb_id_isValid = ::OpenAPI::fromJsonValue(global_gnb_id, json[QString("globalGnbId")]);
    m_global_gnb_id_isSet = !json[QString("globalGnbId")].isNull() && m_global_gnb_id_isValid;
}

QString OAINrLocation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINrLocation::asJsonObject() const {
    QJsonObject obj;
    if (tai.isSet()) {
        obj.insert(QString("tai"), ::OpenAPI::toJsonValue(tai));
    }
    if (ncgi.isSet()) {
        obj.insert(QString("ncgi"), ::OpenAPI::toJsonValue(ncgi));
    }
    if (m_age_of_location_information_isSet) {
        obj.insert(QString("ageOfLocationInformation"), ::OpenAPI::toJsonValue(age_of_location_information));
    }
    if (m_ue_location_timestamp_isSet) {
        obj.insert(QString("ueLocationTimestamp"), ::OpenAPI::toJsonValue(ue_location_timestamp));
    }
    if (m_geographical_information_isSet) {
        obj.insert(QString("geographicalInformation"), ::OpenAPI::toJsonValue(geographical_information));
    }
    if (m_geodetic_information_isSet) {
        obj.insert(QString("geodeticInformation"), ::OpenAPI::toJsonValue(geodetic_information));
    }
    if (global_gnb_id.isSet()) {
        obj.insert(QString("globalGnbId"), ::OpenAPI::toJsonValue(global_gnb_id));
    }
    return obj;
}

OAITai OAINrLocation::getTai() const {
    return tai;
}
void OAINrLocation::setTai(const OAITai &tai) {
    this->tai = tai;
    this->m_tai_isSet = true;
}

bool OAINrLocation::is_tai_Set() const{
    return m_tai_isSet;
}

bool OAINrLocation::is_tai_Valid() const{
    return m_tai_isValid;
}

OAINcgi OAINrLocation::getNcgi() const {
    return ncgi;
}
void OAINrLocation::setNcgi(const OAINcgi &ncgi) {
    this->ncgi = ncgi;
    this->m_ncgi_isSet = true;
}

bool OAINrLocation::is_ncgi_Set() const{
    return m_ncgi_isSet;
}

bool OAINrLocation::is_ncgi_Valid() const{
    return m_ncgi_isValid;
}

qint32 OAINrLocation::getAgeOfLocationInformation() const {
    return age_of_location_information;
}
void OAINrLocation::setAgeOfLocationInformation(const qint32 &age_of_location_information) {
    this->age_of_location_information = age_of_location_information;
    this->m_age_of_location_information_isSet = true;
}

bool OAINrLocation::is_age_of_location_information_Set() const{
    return m_age_of_location_information_isSet;
}

bool OAINrLocation::is_age_of_location_information_Valid() const{
    return m_age_of_location_information_isValid;
}

QDateTime OAINrLocation::getUeLocationTimestamp() const {
    return ue_location_timestamp;
}
void OAINrLocation::setUeLocationTimestamp(const QDateTime &ue_location_timestamp) {
    this->ue_location_timestamp = ue_location_timestamp;
    this->m_ue_location_timestamp_isSet = true;
}

bool OAINrLocation::is_ue_location_timestamp_Set() const{
    return m_ue_location_timestamp_isSet;
}

bool OAINrLocation::is_ue_location_timestamp_Valid() const{
    return m_ue_location_timestamp_isValid;
}

QString OAINrLocation::getGeographicalInformation() const {
    return geographical_information;
}
void OAINrLocation::setGeographicalInformation(const QString &geographical_information) {
    this->geographical_information = geographical_information;
    this->m_geographical_information_isSet = true;
}

bool OAINrLocation::is_geographical_information_Set() const{
    return m_geographical_information_isSet;
}

bool OAINrLocation::is_geographical_information_Valid() const{
    return m_geographical_information_isValid;
}

QString OAINrLocation::getGeodeticInformation() const {
    return geodetic_information;
}
void OAINrLocation::setGeodeticInformation(const QString &geodetic_information) {
    this->geodetic_information = geodetic_information;
    this->m_geodetic_information_isSet = true;
}

bool OAINrLocation::is_geodetic_information_Set() const{
    return m_geodetic_information_isSet;
}

bool OAINrLocation::is_geodetic_information_Valid() const{
    return m_geodetic_information_isValid;
}

OAIGlobalRanNodeId OAINrLocation::getGlobalGnbId() const {
    return global_gnb_id;
}
void OAINrLocation::setGlobalGnbId(const OAIGlobalRanNodeId &global_gnb_id) {
    this->global_gnb_id = global_gnb_id;
    this->m_global_gnb_id_isSet = true;
}

bool OAINrLocation::is_global_gnb_id_Set() const{
    return m_global_gnb_id_isSet;
}

bool OAINrLocation::is_global_gnb_id_Valid() const{
    return m_global_gnb_id_isValid;
}

bool OAINrLocation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (tai.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (ncgi.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_age_of_location_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ue_location_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_geographical_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_geodetic_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (global_gnb_id.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINrLocation::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_tai_isValid && m_ncgi_isValid && true;
}

} // namespace OpenAPI
