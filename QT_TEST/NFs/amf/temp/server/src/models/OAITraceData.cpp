/**
 * Namf_Communication
 * AMF Communication Service Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
 *
 * The version of the OpenAPI document: 1.1.5
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITraceData.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITraceData::OAITraceData(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITraceData::OAITraceData() {
    this->initializeModel();
}

OAITraceData::~OAITraceData() {}

void OAITraceData::initializeModel() {

    m_trace_ref_isSet = false;
    m_trace_ref_isValid = false;

    m_trace_depth_isSet = false;
    m_trace_depth_isValid = false;

    m_ne_type_list_isSet = false;
    m_ne_type_list_isValid = false;

    m_event_list_isSet = false;
    m_event_list_isValid = false;

    m_collection_entity_ipv4_addr_isSet = false;
    m_collection_entity_ipv4_addr_isValid = false;

    m_collection_entity_ipv6_addr_isSet = false;
    m_collection_entity_ipv6_addr_isValid = false;

    m_interface_list_isSet = false;
    m_interface_list_isValid = false;
}

void OAITraceData::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITraceData::fromJsonObject(QJsonObject json) {

    m_trace_ref_isValid = ::OpenAPI::fromJsonValue(trace_ref, json[QString("traceRef")]);
    m_trace_ref_isSet = !json[QString("traceRef")].isNull() && m_trace_ref_isValid;

    m_trace_depth_isValid = ::OpenAPI::fromJsonValue(trace_depth, json[QString("traceDepth")]);
    m_trace_depth_isSet = !json[QString("traceDepth")].isNull() && m_trace_depth_isValid;

    m_ne_type_list_isValid = ::OpenAPI::fromJsonValue(ne_type_list, json[QString("neTypeList")]);
    m_ne_type_list_isSet = !json[QString("neTypeList")].isNull() && m_ne_type_list_isValid;

    m_event_list_isValid = ::OpenAPI::fromJsonValue(event_list, json[QString("eventList")]);
    m_event_list_isSet = !json[QString("eventList")].isNull() && m_event_list_isValid;

    m_collection_entity_ipv4_addr_isValid = ::OpenAPI::fromJsonValue(collection_entity_ipv4_addr, json[QString("collectionEntityIpv4Addr")]);
    m_collection_entity_ipv4_addr_isSet = !json[QString("collectionEntityIpv4Addr")].isNull() && m_collection_entity_ipv4_addr_isValid;

    m_collection_entity_ipv6_addr_isValid = ::OpenAPI::fromJsonValue(collection_entity_ipv6_addr, json[QString("collectionEntityIpv6Addr")]);
    m_collection_entity_ipv6_addr_isSet = !json[QString("collectionEntityIpv6Addr")].isNull() && m_collection_entity_ipv6_addr_isValid;

    m_interface_list_isValid = ::OpenAPI::fromJsonValue(interface_list, json[QString("interfaceList")]);
    m_interface_list_isSet = !json[QString("interfaceList")].isNull() && m_interface_list_isValid;
}

QString OAITraceData::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITraceData::asJsonObject() const {
    QJsonObject obj;
    if (m_trace_ref_isSet) {
        obj.insert(QString("traceRef"), ::OpenAPI::toJsonValue(trace_ref));
    }
    if (trace_depth.isSet()) {
        obj.insert(QString("traceDepth"), ::OpenAPI::toJsonValue(trace_depth));
    }
    if (m_ne_type_list_isSet) {
        obj.insert(QString("neTypeList"), ::OpenAPI::toJsonValue(ne_type_list));
    }
    if (m_event_list_isSet) {
        obj.insert(QString("eventList"), ::OpenAPI::toJsonValue(event_list));
    }
    if (m_collection_entity_ipv4_addr_isSet) {
        obj.insert(QString("collectionEntityIpv4Addr"), ::OpenAPI::toJsonValue(collection_entity_ipv4_addr));
    }
    if (collection_entity_ipv6_addr.isSet()) {
        obj.insert(QString("collectionEntityIpv6Addr"), ::OpenAPI::toJsonValue(collection_entity_ipv6_addr));
    }
    if (m_interface_list_isSet) {
        obj.insert(QString("interfaceList"), ::OpenAPI::toJsonValue(interface_list));
    }
    return obj;
}

QString OAITraceData::getTraceRef() const {
    return trace_ref;
}
void OAITraceData::setTraceRef(const QString &trace_ref) {
    this->trace_ref = trace_ref;
    this->m_trace_ref_isSet = true;
}

bool OAITraceData::is_trace_ref_Set() const{
    return m_trace_ref_isSet;
}

bool OAITraceData::is_trace_ref_Valid() const{
    return m_trace_ref_isValid;
}

OAITraceDepth OAITraceData::getTraceDepth() const {
    return trace_depth;
}
void OAITraceData::setTraceDepth(const OAITraceDepth &trace_depth) {
    this->trace_depth = trace_depth;
    this->m_trace_depth_isSet = true;
}

bool OAITraceData::is_trace_depth_Set() const{
    return m_trace_depth_isSet;
}

bool OAITraceData::is_trace_depth_Valid() const{
    return m_trace_depth_isValid;
}

QString OAITraceData::getNeTypeList() const {
    return ne_type_list;
}
void OAITraceData::setNeTypeList(const QString &ne_type_list) {
    this->ne_type_list = ne_type_list;
    this->m_ne_type_list_isSet = true;
}

bool OAITraceData::is_ne_type_list_Set() const{
    return m_ne_type_list_isSet;
}

bool OAITraceData::is_ne_type_list_Valid() const{
    return m_ne_type_list_isValid;
}

QString OAITraceData::getEventList() const {
    return event_list;
}
void OAITraceData::setEventList(const QString &event_list) {
    this->event_list = event_list;
    this->m_event_list_isSet = true;
}

bool OAITraceData::is_event_list_Set() const{
    return m_event_list_isSet;
}

bool OAITraceData::is_event_list_Valid() const{
    return m_event_list_isValid;
}

QString OAITraceData::getCollectionEntityIpv4Addr() const {
    return collection_entity_ipv4_addr;
}
void OAITraceData::setCollectionEntityIpv4Addr(const QString &collection_entity_ipv4_addr) {
    this->collection_entity_ipv4_addr = collection_entity_ipv4_addr;
    this->m_collection_entity_ipv4_addr_isSet = true;
}

bool OAITraceData::is_collection_entity_ipv4_addr_Set() const{
    return m_collection_entity_ipv4_addr_isSet;
}

bool OAITraceData::is_collection_entity_ipv4_addr_Valid() const{
    return m_collection_entity_ipv4_addr_isValid;
}

OAIIpv6Addr OAITraceData::getCollectionEntityIpv6Addr() const {
    return collection_entity_ipv6_addr;
}
void OAITraceData::setCollectionEntityIpv6Addr(const OAIIpv6Addr &collection_entity_ipv6_addr) {
    this->collection_entity_ipv6_addr = collection_entity_ipv6_addr;
    this->m_collection_entity_ipv6_addr_isSet = true;
}

bool OAITraceData::is_collection_entity_ipv6_addr_Set() const{
    return m_collection_entity_ipv6_addr_isSet;
}

bool OAITraceData::is_collection_entity_ipv6_addr_Valid() const{
    return m_collection_entity_ipv6_addr_isValid;
}

QString OAITraceData::getInterfaceList() const {
    return interface_list;
}
void OAITraceData::setInterfaceList(const QString &interface_list) {
    this->interface_list = interface_list;
    this->m_interface_list_isSet = true;
}

bool OAITraceData::is_interface_list_Set() const{
    return m_interface_list_isSet;
}

bool OAITraceData::is_interface_list_Valid() const{
    return m_interface_list_isValid;
}

bool OAITraceData::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_trace_ref_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (trace_depth.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ne_type_list_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_event_list_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_collection_entity_ipv4_addr_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (collection_entity_ipv6_addr.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_interface_list_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITraceData::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_trace_ref_isValid && m_trace_depth_isValid && m_ne_type_list_isValid && m_event_list_isValid && true;
}

} // namespace OpenAPI
