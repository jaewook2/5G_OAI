/**
 * Namf_Communication
 * AMF Communication Service Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
 *
 * The version of the OpenAPI document: 1.1.5
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIEutraLocation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIEutraLocation::OAIEutraLocation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIEutraLocation::OAIEutraLocation() {
    this->initializeModel();
}

OAIEutraLocation::~OAIEutraLocation() {}

void OAIEutraLocation::initializeModel() {

    m_tai_isSet = false;
    m_tai_isValid = false;

    m_ignore_tai_isSet = false;
    m_ignore_tai_isValid = false;

    m_ecgi_isSet = false;
    m_ecgi_isValid = false;

    m_ignore_ecgi_isSet = false;
    m_ignore_ecgi_isValid = false;

    m_age_of_location_information_isSet = false;
    m_age_of_location_information_isValid = false;

    m_ue_location_timestamp_isSet = false;
    m_ue_location_timestamp_isValid = false;

    m_geographical_information_isSet = false;
    m_geographical_information_isValid = false;

    m_geodetic_information_isSet = false;
    m_geodetic_information_isValid = false;

    m_global_ngenb_id_isSet = false;
    m_global_ngenb_id_isValid = false;

    m_global_enb_id_isSet = false;
    m_global_enb_id_isValid = false;
}

void OAIEutraLocation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIEutraLocation::fromJsonObject(QJsonObject json) {

    m_tai_isValid = ::OpenAPI::fromJsonValue(tai, json[QString("tai")]);
    m_tai_isSet = !json[QString("tai")].isNull() && m_tai_isValid;

    m_ignore_tai_isValid = ::OpenAPI::fromJsonValue(ignore_tai, json[QString("ignoreTai")]);
    m_ignore_tai_isSet = !json[QString("ignoreTai")].isNull() && m_ignore_tai_isValid;

    m_ecgi_isValid = ::OpenAPI::fromJsonValue(ecgi, json[QString("ecgi")]);
    m_ecgi_isSet = !json[QString("ecgi")].isNull() && m_ecgi_isValid;

    m_ignore_ecgi_isValid = ::OpenAPI::fromJsonValue(ignore_ecgi, json[QString("ignoreEcgi")]);
    m_ignore_ecgi_isSet = !json[QString("ignoreEcgi")].isNull() && m_ignore_ecgi_isValid;

    m_age_of_location_information_isValid = ::OpenAPI::fromJsonValue(age_of_location_information, json[QString("ageOfLocationInformation")]);
    m_age_of_location_information_isSet = !json[QString("ageOfLocationInformation")].isNull() && m_age_of_location_information_isValid;

    m_ue_location_timestamp_isValid = ::OpenAPI::fromJsonValue(ue_location_timestamp, json[QString("ueLocationTimestamp")]);
    m_ue_location_timestamp_isSet = !json[QString("ueLocationTimestamp")].isNull() && m_ue_location_timestamp_isValid;

    m_geographical_information_isValid = ::OpenAPI::fromJsonValue(geographical_information, json[QString("geographicalInformation")]);
    m_geographical_information_isSet = !json[QString("geographicalInformation")].isNull() && m_geographical_information_isValid;

    m_geodetic_information_isValid = ::OpenAPI::fromJsonValue(geodetic_information, json[QString("geodeticInformation")]);
    m_geodetic_information_isSet = !json[QString("geodeticInformation")].isNull() && m_geodetic_information_isValid;

    m_global_ngenb_id_isValid = ::OpenAPI::fromJsonValue(global_ngenb_id, json[QString("globalNgenbId")]);
    m_global_ngenb_id_isSet = !json[QString("globalNgenbId")].isNull() && m_global_ngenb_id_isValid;

    m_global_enb_id_isValid = ::OpenAPI::fromJsonValue(global_enb_id, json[QString("globalENbId")]);
    m_global_enb_id_isSet = !json[QString("globalENbId")].isNull() && m_global_enb_id_isValid;
}

QString OAIEutraLocation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIEutraLocation::asJsonObject() const {
    QJsonObject obj;
    if (tai.isSet()) {
        obj.insert(QString("tai"), ::OpenAPI::toJsonValue(tai));
    }
    if (m_ignore_tai_isSet) {
        obj.insert(QString("ignoreTai"), ::OpenAPI::toJsonValue(ignore_tai));
    }
    if (ecgi.isSet()) {
        obj.insert(QString("ecgi"), ::OpenAPI::toJsonValue(ecgi));
    }
    if (m_ignore_ecgi_isSet) {
        obj.insert(QString("ignoreEcgi"), ::OpenAPI::toJsonValue(ignore_ecgi));
    }
    if (m_age_of_location_information_isSet) {
        obj.insert(QString("ageOfLocationInformation"), ::OpenAPI::toJsonValue(age_of_location_information));
    }
    if (m_ue_location_timestamp_isSet) {
        obj.insert(QString("ueLocationTimestamp"), ::OpenAPI::toJsonValue(ue_location_timestamp));
    }
    if (m_geographical_information_isSet) {
        obj.insert(QString("geographicalInformation"), ::OpenAPI::toJsonValue(geographical_information));
    }
    if (m_geodetic_information_isSet) {
        obj.insert(QString("geodeticInformation"), ::OpenAPI::toJsonValue(geodetic_information));
    }
    if (global_ngenb_id.isSet()) {
        obj.insert(QString("globalNgenbId"), ::OpenAPI::toJsonValue(global_ngenb_id));
    }
    if (global_enb_id.isSet()) {
        obj.insert(QString("globalENbId"), ::OpenAPI::toJsonValue(global_enb_id));
    }
    return obj;
}

OAITai OAIEutraLocation::getTai() const {
    return tai;
}
void OAIEutraLocation::setTai(const OAITai &tai) {
    this->tai = tai;
    this->m_tai_isSet = true;
}

bool OAIEutraLocation::is_tai_Set() const{
    return m_tai_isSet;
}

bool OAIEutraLocation::is_tai_Valid() const{
    return m_tai_isValid;
}

bool OAIEutraLocation::isIgnoreTai() const {
    return ignore_tai;
}
void OAIEutraLocation::setIgnoreTai(const bool &ignore_tai) {
    this->ignore_tai = ignore_tai;
    this->m_ignore_tai_isSet = true;
}

bool OAIEutraLocation::is_ignore_tai_Set() const{
    return m_ignore_tai_isSet;
}

bool OAIEutraLocation::is_ignore_tai_Valid() const{
    return m_ignore_tai_isValid;
}

OAIEcgi OAIEutraLocation::getEcgi() const {
    return ecgi;
}
void OAIEutraLocation::setEcgi(const OAIEcgi &ecgi) {
    this->ecgi = ecgi;
    this->m_ecgi_isSet = true;
}

bool OAIEutraLocation::is_ecgi_Set() const{
    return m_ecgi_isSet;
}

bool OAIEutraLocation::is_ecgi_Valid() const{
    return m_ecgi_isValid;
}

bool OAIEutraLocation::isIgnoreEcgi() const {
    return ignore_ecgi;
}
void OAIEutraLocation::setIgnoreEcgi(const bool &ignore_ecgi) {
    this->ignore_ecgi = ignore_ecgi;
    this->m_ignore_ecgi_isSet = true;
}

bool OAIEutraLocation::is_ignore_ecgi_Set() const{
    return m_ignore_ecgi_isSet;
}

bool OAIEutraLocation::is_ignore_ecgi_Valid() const{
    return m_ignore_ecgi_isValid;
}

qint32 OAIEutraLocation::getAgeOfLocationInformation() const {
    return age_of_location_information;
}
void OAIEutraLocation::setAgeOfLocationInformation(const qint32 &age_of_location_information) {
    this->age_of_location_information = age_of_location_information;
    this->m_age_of_location_information_isSet = true;
}

bool OAIEutraLocation::is_age_of_location_information_Set() const{
    return m_age_of_location_information_isSet;
}

bool OAIEutraLocation::is_age_of_location_information_Valid() const{
    return m_age_of_location_information_isValid;
}

QDateTime OAIEutraLocation::getUeLocationTimestamp() const {
    return ue_location_timestamp;
}
void OAIEutraLocation::setUeLocationTimestamp(const QDateTime &ue_location_timestamp) {
    this->ue_location_timestamp = ue_location_timestamp;
    this->m_ue_location_timestamp_isSet = true;
}

bool OAIEutraLocation::is_ue_location_timestamp_Set() const{
    return m_ue_location_timestamp_isSet;
}

bool OAIEutraLocation::is_ue_location_timestamp_Valid() const{
    return m_ue_location_timestamp_isValid;
}

QString OAIEutraLocation::getGeographicalInformation() const {
    return geographical_information;
}
void OAIEutraLocation::setGeographicalInformation(const QString &geographical_information) {
    this->geographical_information = geographical_information;
    this->m_geographical_information_isSet = true;
}

bool OAIEutraLocation::is_geographical_information_Set() const{
    return m_geographical_information_isSet;
}

bool OAIEutraLocation::is_geographical_information_Valid() const{
    return m_geographical_information_isValid;
}

QString OAIEutraLocation::getGeodeticInformation() const {
    return geodetic_information;
}
void OAIEutraLocation::setGeodeticInformation(const QString &geodetic_information) {
    this->geodetic_information = geodetic_information;
    this->m_geodetic_information_isSet = true;
}

bool OAIEutraLocation::is_geodetic_information_Set() const{
    return m_geodetic_information_isSet;
}

bool OAIEutraLocation::is_geodetic_information_Valid() const{
    return m_geodetic_information_isValid;
}

OAIGlobalRanNodeId OAIEutraLocation::getGlobalNgenbId() const {
    return global_ngenb_id;
}
void OAIEutraLocation::setGlobalNgenbId(const OAIGlobalRanNodeId &global_ngenb_id) {
    this->global_ngenb_id = global_ngenb_id;
    this->m_global_ngenb_id_isSet = true;
}

bool OAIEutraLocation::is_global_ngenb_id_Set() const{
    return m_global_ngenb_id_isSet;
}

bool OAIEutraLocation::is_global_ngenb_id_Valid() const{
    return m_global_ngenb_id_isValid;
}

OAIGlobalRanNodeId OAIEutraLocation::getGlobalEnbId() const {
    return global_enb_id;
}
void OAIEutraLocation::setGlobalEnbId(const OAIGlobalRanNodeId &global_enb_id) {
    this->global_enb_id = global_enb_id;
    this->m_global_enb_id_isSet = true;
}

bool OAIEutraLocation::is_global_enb_id_Set() const{
    return m_global_enb_id_isSet;
}

bool OAIEutraLocation::is_global_enb_id_Valid() const{
    return m_global_enb_id_isValid;
}

bool OAIEutraLocation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (tai.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ignore_tai_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (ecgi.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ignore_ecgi_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_age_of_location_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ue_location_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_geographical_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_geodetic_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (global_ngenb_id.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (global_enb_id.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIEutraLocation::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_tai_isValid && m_ecgi_isValid && true;
}

} // namespace OpenAPI
