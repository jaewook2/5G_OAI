/**
 * Namf_Communication
 * AMF Communication Service Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
 *
 * The version of the OpenAPI document: 1.1.5
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUtraLocation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIUtraLocation::OAIUtraLocation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIUtraLocation::OAIUtraLocation() {
    this->initializeModel();
}

OAIUtraLocation::~OAIUtraLocation() {}

void OAIUtraLocation::initializeModel() {

    m_cgi_isSet = false;
    m_cgi_isValid = false;

    m_sai_isSet = false;
    m_sai_isValid = false;

    m_lai_isSet = false;
    m_lai_isValid = false;

    m_rai_isSet = false;
    m_rai_isValid = false;

    m_age_of_location_information_isSet = false;
    m_age_of_location_information_isValid = false;

    m_ue_location_timestamp_isSet = false;
    m_ue_location_timestamp_isValid = false;

    m_geographical_information_isSet = false;
    m_geographical_information_isValid = false;

    m_geodetic_information_isSet = false;
    m_geodetic_information_isValid = false;
}

void OAIUtraLocation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIUtraLocation::fromJsonObject(QJsonObject json) {

    m_cgi_isValid = ::OpenAPI::fromJsonValue(cgi, json[QString("cgi")]);
    m_cgi_isSet = !json[QString("cgi")].isNull() && m_cgi_isValid;

    m_sai_isValid = ::OpenAPI::fromJsonValue(sai, json[QString("sai")]);
    m_sai_isSet = !json[QString("sai")].isNull() && m_sai_isValid;

    m_lai_isValid = ::OpenAPI::fromJsonValue(lai, json[QString("lai")]);
    m_lai_isSet = !json[QString("lai")].isNull() && m_lai_isValid;

    m_rai_isValid = ::OpenAPI::fromJsonValue(rai, json[QString("rai")]);
    m_rai_isSet = !json[QString("rai")].isNull() && m_rai_isValid;

    m_age_of_location_information_isValid = ::OpenAPI::fromJsonValue(age_of_location_information, json[QString("ageOfLocationInformation")]);
    m_age_of_location_information_isSet = !json[QString("ageOfLocationInformation")].isNull() && m_age_of_location_information_isValid;

    m_ue_location_timestamp_isValid = ::OpenAPI::fromJsonValue(ue_location_timestamp, json[QString("ueLocationTimestamp")]);
    m_ue_location_timestamp_isSet = !json[QString("ueLocationTimestamp")].isNull() && m_ue_location_timestamp_isValid;

    m_geographical_information_isValid = ::OpenAPI::fromJsonValue(geographical_information, json[QString("geographicalInformation")]);
    m_geographical_information_isSet = !json[QString("geographicalInformation")].isNull() && m_geographical_information_isValid;

    m_geodetic_information_isValid = ::OpenAPI::fromJsonValue(geodetic_information, json[QString("geodeticInformation")]);
    m_geodetic_information_isSet = !json[QString("geodeticInformation")].isNull() && m_geodetic_information_isValid;
}

QString OAIUtraLocation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIUtraLocation::asJsonObject() const {
    QJsonObject obj;
    if (cgi.isSet()) {
        obj.insert(QString("cgi"), ::OpenAPI::toJsonValue(cgi));
    }
    if (sai.isSet()) {
        obj.insert(QString("sai"), ::OpenAPI::toJsonValue(sai));
    }
    if (lai.isSet()) {
        obj.insert(QString("lai"), ::OpenAPI::toJsonValue(lai));
    }
    if (rai.isSet()) {
        obj.insert(QString("rai"), ::OpenAPI::toJsonValue(rai));
    }
    if (m_age_of_location_information_isSet) {
        obj.insert(QString("ageOfLocationInformation"), ::OpenAPI::toJsonValue(age_of_location_information));
    }
    if (m_ue_location_timestamp_isSet) {
        obj.insert(QString("ueLocationTimestamp"), ::OpenAPI::toJsonValue(ue_location_timestamp));
    }
    if (m_geographical_information_isSet) {
        obj.insert(QString("geographicalInformation"), ::OpenAPI::toJsonValue(geographical_information));
    }
    if (m_geodetic_information_isSet) {
        obj.insert(QString("geodeticInformation"), ::OpenAPI::toJsonValue(geodetic_information));
    }
    return obj;
}

OAICellGlobalId OAIUtraLocation::getCgi() const {
    return cgi;
}
void OAIUtraLocation::setCgi(const OAICellGlobalId &cgi) {
    this->cgi = cgi;
    this->m_cgi_isSet = true;
}

bool OAIUtraLocation::is_cgi_Set() const{
    return m_cgi_isSet;
}

bool OAIUtraLocation::is_cgi_Valid() const{
    return m_cgi_isValid;
}

OAIServiceAreaId OAIUtraLocation::getSai() const {
    return sai;
}
void OAIUtraLocation::setSai(const OAIServiceAreaId &sai) {
    this->sai = sai;
    this->m_sai_isSet = true;
}

bool OAIUtraLocation::is_sai_Set() const{
    return m_sai_isSet;
}

bool OAIUtraLocation::is_sai_Valid() const{
    return m_sai_isValid;
}

OAILocationAreaId OAIUtraLocation::getLai() const {
    return lai;
}
void OAIUtraLocation::setLai(const OAILocationAreaId &lai) {
    this->lai = lai;
    this->m_lai_isSet = true;
}

bool OAIUtraLocation::is_lai_Set() const{
    return m_lai_isSet;
}

bool OAIUtraLocation::is_lai_Valid() const{
    return m_lai_isValid;
}

OAIRoutingAreaId OAIUtraLocation::getRai() const {
    return rai;
}
void OAIUtraLocation::setRai(const OAIRoutingAreaId &rai) {
    this->rai = rai;
    this->m_rai_isSet = true;
}

bool OAIUtraLocation::is_rai_Set() const{
    return m_rai_isSet;
}

bool OAIUtraLocation::is_rai_Valid() const{
    return m_rai_isValid;
}

qint32 OAIUtraLocation::getAgeOfLocationInformation() const {
    return age_of_location_information;
}
void OAIUtraLocation::setAgeOfLocationInformation(const qint32 &age_of_location_information) {
    this->age_of_location_information = age_of_location_information;
    this->m_age_of_location_information_isSet = true;
}

bool OAIUtraLocation::is_age_of_location_information_Set() const{
    return m_age_of_location_information_isSet;
}

bool OAIUtraLocation::is_age_of_location_information_Valid() const{
    return m_age_of_location_information_isValid;
}

QDateTime OAIUtraLocation::getUeLocationTimestamp() const {
    return ue_location_timestamp;
}
void OAIUtraLocation::setUeLocationTimestamp(const QDateTime &ue_location_timestamp) {
    this->ue_location_timestamp = ue_location_timestamp;
    this->m_ue_location_timestamp_isSet = true;
}

bool OAIUtraLocation::is_ue_location_timestamp_Set() const{
    return m_ue_location_timestamp_isSet;
}

bool OAIUtraLocation::is_ue_location_timestamp_Valid() const{
    return m_ue_location_timestamp_isValid;
}

QString OAIUtraLocation::getGeographicalInformation() const {
    return geographical_information;
}
void OAIUtraLocation::setGeographicalInformation(const QString &geographical_information) {
    this->geographical_information = geographical_information;
    this->m_geographical_information_isSet = true;
}

bool OAIUtraLocation::is_geographical_information_Set() const{
    return m_geographical_information_isSet;
}

bool OAIUtraLocation::is_geographical_information_Valid() const{
    return m_geographical_information_isValid;
}

QString OAIUtraLocation::getGeodeticInformation() const {
    return geodetic_information;
}
void OAIUtraLocation::setGeodeticInformation(const QString &geodetic_information) {
    this->geodetic_information = geodetic_information;
    this->m_geodetic_information_isSet = true;
}

bool OAIUtraLocation::is_geodetic_information_Set() const{
    return m_geodetic_information_isSet;
}

bool OAIUtraLocation::is_geodetic_information_Valid() const{
    return m_geodetic_information_isValid;
}

bool OAIUtraLocation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (cgi.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (sai.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (lai.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (rai.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_age_of_location_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ue_location_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_geographical_information_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_geodetic_information_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIUtraLocation::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
